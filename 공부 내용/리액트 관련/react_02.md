# 리액트(React)
----
## 리액트란?
- Component에 대해 선언적 사용이 가능한 JS 라이브러리
    - Component
        - view를 구성하는 작은 단위 (Nesting & Configuration)
        - 독립적으로 재사용이 가능한 단위 (Reusability)
        - 대문자로 시작
    - Props
        - 하나의 Component에서 다른 Component로 전달되는 argument(전달인자)
        - 상위 Component가 하위 Component의 Props를 정의해 준다. (Flux Architecture)
        - 하위 컴포넌트에 대한 Props 타입은 interface로 정의한다.
        - 이벤트 핸들러도 전달 가능
- SPA(Single Page Application) 개발도구
    - 서버로부터 완전한 새로운 페이지를 불러오지 않고, 현재의 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션이나 웹 사이트를 말함
- Flux Architecture
    - '상위 요소 => 하위 요소'로의 단방향 데이터 흐름 아키텍쳐
- JSX(JavaScript Extecture)
    - JS에서 HTML 문법을 사용할 수 있게 한 확장 구문(Extension)
    - 마크업(MarkUp) 구조를 HTML 페이지 대신 JS(JavaScript)/TS(TypeScript)에서 사용할 수 있게 함
        - 마크업 언어 : HTML과 같은 마크(Mark) 또는 태그(Tag)로 둘러싸인 언어
    - 원리 상 React.createElement() 호출하여 컴파일 됨
- Virtual DOM
    - 웹 페이지에 변화 발생 시, 실제 DOM에 적용되기 전에 Virtual DOM에 우선 적용을 시킨 후, 적용한다.
        - Virtual DOM은 렌더링 과정이 필요 없기 때문에 연산 비용이 실제 DOM 보다 적음
- CSR 방식으로 작동함 - 첫 로딩이 느리다는 단점
    - 서버는 비어있는 HTML을 응답하고, 클라이언트쪽에서 화면을 그림
----
## 렌더링(rendering)이란?
- 서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정
- 렌더링 과정
    1. 브라우저는 서버로부터 HTML 문서를 다운 받는다. 
    2. 렌더링 엔진은 HTML 문서를 파싱해서 DOM 트리를 만든다.
    3. 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱하여 CSSOM 트리를 만든다.
        - 스타일은 브라우저의 자체 스타일, 사용자 정의 스타일, HTML 태그에 걸려있는 스타일 순서로 처리됨.
        - 즉, 나중에 처리되는 스타일을 따르게 됨.
        - 따라서 인라인으로 들어가있는 스타일 속성이 우선순위를 가짐.
    5. DOM 트리와 CSSOM을 결합하여 렌더링 트리를 형성한다.
        - 화면에 드러나지 않는 head 태그나 display 속성에 none 값이 할당된 요소는 렌더링 트리에 포함되지 않는다.
    6. 렌더링 트리에서 각 노드의 크기와 위치를 계산한다( = 레이아웃 단계 or 리플로우).
        - 각 객체의 정확한 크기와 위치 파악을 위해 브라우저는 렌더링 트리의 루트부터 순회함
    7. 개별 노드를 화면에 그린다.( = 페인팅 or 래스터화)
- 모든 HTML을 파싱할 때까지 기다리지 않고, 배치와 그리기 과정을 진행함
- 렌더링이 완료된 상태에서 
    1. 레이아웃이 변경될 경우 리플로우(Reflow) 또는 리페인트(Repaint)가 발생
    2. 레이아웃 변경 없이 엘리먼트만 변경될 때는 리페인트(Repaint)만 발생
----
## 최적의 렌더링 성능을 얻기위한 최적화 방법 - 리플로우 최소화
1. 인라인 스타일 사용 X
    - 인라인 스타일 사용 시 수차례의 리플로우 발생
    - 인라인 스타일 사용 대신, 외부 스타일을 사용하면 리플로우가 1번만 발생함
2. 작업 그루핑
    - DOM 요소의 정보를 요청하고 변경하는 코드는 같은 형태의 작업끼리 묶어서 실행시키는 것이 좋다.
3. 노출 제어
    - display 속성 값을 none으로 하면, 렌더링 트리에서 노드가 빠지게 됨
    - 따라서 노드를 감추고 스타일을 변경한 후, 노드를 노출시키는 것이 리플로우와 리페인트의 발생 횟수를 줄일 수 있음
4. 노드 복제
    - 변경하려는 요소의 노드를 복제한 후, 복제된 노드에 작업을 하고 교체를 해주게 되면 리플로우와 리페인트는 1번만 발생 함
5. 캐싱
    - 별도의 변수에 자주 사용하는 값을 저장하는 것
----
## SSR(Server Side Rendering) vs CSR(Client Side Rendering)
- SSR
    - 서버에 HTML 파일을 저장해두었다가, 요청 발생 시 모든 파일을 브라우저에 전달하는 방식
    - 장점
        1. 검색엔진 최적화(SEO) 가능
        2. 성능 개선 - 초기 로딩 속도 빠름, 렌더링 작업 완료 전에 사용자가 사이트를 이용할 수 있음
        3. 정적인 사이트에 좋음
            - SEO, 인덱싱, 크롤링에 최적화 되어있음
    - 단점
        1. 잦은 서버 요청
        2. 전체적으로 느린 페이지 렌더링
        3. 페이지 요청마다 페이지 새로고침 발생(리로딩)
            - 트래픽 증가
            - 페이지 이동 시 화면이 깜빡거림
        4. 서버 렌더링에 따른 부하가 발생
        5. 사이트 상호 작용의 부족
- CSR
    - 브라우저가 서버에 HTML과 JS 파일을 요청한 후 로드되면, 사용자의 상호작용에따라 JavaScript를 이둉하여 동적으로 렌더링 시키는 방법
    - 장점
        1. 첫 요청 시 한개의 페이지만 불러오게 된다.
        2. 필요한 부분만 리로딩없이 서버로부터 받아서 화면을 갱신 함
        3. 사이트 상호 작용이 활발
        4. 웹 어플리케이션에 좋음
    - 단점
        1. 초기 구동 속도가 느림
        2. 검색엔진 최적화(SEO)가 어려움
        3. 추가적인 라이브러리가 필요함
----
## 리액트의 장점
- 한 HTML 페이지로 여러 HTML 페이지가 렌더링 된 것처럼 보이게 함
- 배포가 간단하다.
- 필요한 데이터만을 전달받아 페이지를 갱신함
    - 트래픽 감소, 새로고침 발생 안함
    - 네이티브 앱과 유사한 UX
        - 네이티브 앱
            - SDK(Software Development Kit)기반으로 개발된 애플리케이션
            - 모바일 기기에 직접 다운로드하여 로컬에 저장되는 실행파일
            - 우리가 일반적으로 설치해서 사용하는 앱
        - UX(User Experience)
            - 사용자가 어떤 제품, 시스템, 서비스 등을 직접적 or 간접적으로 이용하면서 느끼는 반응과 행동들과 같은 경험을 총체적으로 설계하는 것
- SPA는 JS 기반 비동기 모델(클라이언트 렌더링 방식)이지만 React 프레임워크는 서버 사이드 렌더링도 지원
----
## 자바스크립트(JavaScript)
- 웹 개발에 주로 사용 됨
    - 웹 페이지를 대화식으로 만드는 프로그래밍 언어
- 폼 유효성 검사, 애니메이션 적용 및 이벤트 생성을 수행
- 클라이언트 측 스크립팅 언어
    - 사용자가 웹 브라우저를 열고 웹 페이지 요청 시, 해당 요청이 웹 서버로 이동
----
## 타입스크립트(TypeScript)
- JavaScript의 상위 집합
    - Object의 타입을 명시할 수 있다는 것이 JavaScript와의 가장 큰 차이점
- 타입 에러들을 미리 잡기 위해 사용
- 객체 지향 컴파일 언어
    - 클래스 기반 객체 생성 가능
    - 상속, 캡슐화, 생성자 지원 가능
- 컴파일은 TypeScript를 JavaScript로 변환 하는 것
    - 따라서 TypeScript는 프로그래밍 언어인 동시에 컴파일러이다.
- 장점
    1. 기존 JavaScript와의 호환
    2. 정적 타입 지원
        - 컴파일 단게에서 오류 포착 가능
        - 개발자의 의도를 명확하게 코드로 기술 가능
        - 쉬운 디버깅
    3. Visual Studio Code와의 궁합
        - 같은 Microsoft에서 만든 언어
        - TypeScript로 상상할 수 있는 모든 개발환경을 쉽게 구축 가능
        - 코드 피드백을 매우 잘해줌
    4. TypeScript 컴파일러를 사용하여 TS 파일을 JS 파일로 변환 및 통합 가능
    5. npm 사용
    6. 백엔드와 프론트엔드 통합
        - 모두 TypeScript로 구현 시, 높은 개발 안정성과 편의성 확보 가능
----